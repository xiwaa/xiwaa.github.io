<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于setTimeout中code参数、附加参数和匿名函数的使用]]></title>
    <url>%2F2019%2F08%2F11%2Fwindow.setTimeout%E7%9A%84code%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[setTimeout()的定义(“废话”)window.setTimeout()方法设置一个定时器, 该定时器在定时器到期后执行指定的一段代码. 语法 let timeoutID = scope.setTimeout(function, [, delay, param1, param2, …]); let timeoutID = scope.setTimeout(function, [, delay]); let timeoutID = scope.setTimeout(code, [, delay]) 参数 function: function是你想要到期时间(delay 毫秒)之后执行的函数. code: (可选) 这是一个可选语法, 你可以使用字符串字面量而不是function, 在delay指定毫秒之后编译和执行字符串(使用该语法是不推荐的, 原因和eval()一样, 有安全风险.) delay: (可选) 延迟的毫秒数, 函数的调用会在该延迟之后发生. 如果省略该参数, delay默认取0, 意味着”马上”执行, 或者尽快执行. 不管是哪种情况, 实际的延迟时间可能回避期待的(delay毫秒数)值长. 原因请查看 Reasons for delays longer than specified. 附加参数: param1, … , paramN (可选) [这玩意儿很有用哟] 附加参数, 一旦计时器到期, 他们会作为参数传递给function. 备注：需要注意的是，IE9 及更早的 IE 浏览器不支持向回调函数传递额外参数(本文第二段第1种语法). 返回值 返回值是一个正整数, 表示定时器的编号. 这个值可以传递给clearTimeout()来取消该定时器. 需要注意的是setTimeout()和setInterval()共有一个编号池, 技术上讲, clearTimeout()和clearInterval()可以互换. 但是, 为了避免混淆, 不要混用取消定时函数. 在同一个对象上(一个window或worker), setTimetout()或者setInterval()在后续的调用不会重用同一个定时器编号. 但是不同的对象使用独立的编号池. code参数、附加参数和匿名函数为什么要写这篇幼儿园作文呢? 因为看书的时候发现一个以前不知道的地方–setTimeout()可以接受一个code参数, 也就是一个字符串. 当计时器到期后解析执行这个字符串里面的内容. 我竟然以为只能传函数呢, 啊, 我湿了, 流下失败的泪水, 我是傻X, 我在浅色床单哭泣, 可恶, 坐Uber, 去北极, 自杀吧… 下面放在书上看到的代码: 12345678910111213141516171819202122232425262728293031// 一个移动DOM元素的函数, 通过修改绝对定位元素的left和top属性值实现. 需要的参数是: 元素ID, 最终水平位置(left), 最终垂直位置(top), 时间间隔.// 通过递归的方式来用setTimeout实现了setInterval的效果, 这就是个例子, 实际情况肯定直接上setInterval咯.function moveElement(elementID, finalX, finalY, interval) &#123; if (!document.getElementById) &#123;return false;&#125; if (!document.getElementById(elementID)) &#123;return false;&#125; let elem = document.getElementById(elementID); console.log(elem); let posX = parseInt(elem.style.left); let posY = parseInt(elem.style.top); if (posX === finalX &amp;&amp; posY === finalY) &#123;return true;&#125; if (posX &lt; finalX) &#123; posX++; &#125; if (posX &gt; finalX) &#123; posX--; &#125; if (posY &lt; finalY) &#123; posY++; &#125; if (posY &gt; finalY) &#123; posY--; &#125; elem.style.left = posX + "px"; elem.style.top = posY + "px"; // 注意下面这行, 拼接了一个字符串作为code参数 let repeat = `moveElement("$&#123;elementID&#125;", $&#123;finalX&#125;, $&#123;finalY&#125;, $&#123;interval&#125;)`; let movement = setTimeout(repeat, interval);&#125; 以上代码展示了setTimeout的code参数的用法, 虽然有点骚, 但是这样用是不安全的. 那么咋整? 可以用匿名函数呀! 上面代码最后两行可以这样写: 123let movement = setTimeout(function() &#123; moveElement(elementID, finalX, finalY, interval);&#125;, interval); 看官大老爷可能要说了:”你他喵傻X, setTimeout()支持附加参数, 附加参数会在定时器到期时作为参数传入function参数代表的函数里面, 你他喵倒是用啊, 多打字不累的么?” 好, 咱们用: 1let movement = setTimeout(moveElement, interval, elementID, finalX, finalY, interval); 现在简洁清爽多了! 可是IE不兼容啊, 哈哈哈. 所以不考虑兼容IE的话附加参数爽歪歪, 兼容IE的话就只好当个老实人, 匿名函数用起来. 参考: MDN - window.setTimout() stackoverflow - How can I pass a parameter to a setTimeout() callback?]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.getComputedStyle(可获取伪类元素样式)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%85%B3%E4%BA%8EgetComputedStyle%2F</url>
    <content type="text"><![CDATA[一、window.getComputedStyle 定义语法: window.getComputedStyle(element[, pseudoElt]); Parameter Description element Required. The element to get the computed style for pseudoElement Optional. A pseudo-element to get 12345let elem1 = document.getElementById("elemId");let style = window.getComputedStyle(elem1, null);// 它等价于// let style = document.defaultView.getComputedStyle(elem1, null); 一般来说直接window.getComputedStyle就可以了, 使用document.defaultView.getComputedStyle是为firefox3.6上访问子框架时做兼容, 保险起见用第二种吧. getComputedStyle获取特定元素最终应用了经过计算(computed)的所有的CSS属性和属性的值, 它返回的是一个CSS样式申明对象 object CSSStyleDeclaration . 这个对象是只读的 . 经过计算的样式(computed style) 是应用了来自不同来源的样式之后(来源包括内联样式、内部样式、外部样式表、继承的样式、浏览器赋予的默认样式)最终呈现时那个值. 好像有点绕, 举个栗子: 一个p标签浏览器默认会给它一些样式, 例如padding、width、height之类, 我们可能用了内部样式表将它的height重新定义了, 然后我们可能又在外部样式表或者通过JavaScript把它的height给改了, 那么经过计算的 height就是最终呈现出来的时候的那个值咯 . 前面那一通对height的操作就是计算咯. 二、getComputedStyle VS element.style element.style只能获取到在element元素中style属性里的样式(内联样式), 对于继承的或者浏览器默认赋予的样式这些是没有办法获取的, 而getComputedStyle就是全能型选手了, 从上面的语法部分也看到了, 它支持两个参数, 第一个很明显是要获取样式的元素, 第二个就厉害了可以获取伪类的样式. – See my cow pussy(看我牛逼不)? 以前完全不知道伪类元素还可以获取样式, 长见识了. 获取伪类元素的样式: 1234567891011121314&lt;style&gt; h3::after &#123; content: "rocks!"; &#125;&lt;/style&gt;&lt;h3&gt;generated content&lt;/h3&gt; &lt;script&gt; let h3 = document.querySelector('h3'), result = document.defaultView.getComputedStyle(h3, '::after').getPropertyValue("content"); console.log(`the generated content is: $&#123;result&#125;`); // the generated content is: "rocks!"&lt;/script&gt; getComputedStyle.getPropertyValue()方法用于获取特定属性的值, 参见上面第11行. getComputedStyle 是只读的, 只能获取样式, 不能设置. element.style 可读可写, 可攻可受、可进可退、 欢喜无量、 不可言说… 123let elem = document.getElementById("elem");let elemHeight = elem.style("height"); // 获取样式elem.style("height", "20px"); // 设置样式 三、getComputedStyle VS currentStyleIE6-8不支持 getComputedStyle, 它们有个 currentStyle 属性, element.currentStyle返回元素当前应用的最终CSS属性值, 包含页面内部的style属性和外部引用的CSS文件. 除了不能获取伪类元素的样式, 其他跟getComputedStyle差不多. 为了兼容可如下操作(以获取height为例): 1element.currentStyle? element.currentSyle["height"]: document.defaultView.getComputedStyle(element, null).getProperty("height"); 参考: MDN - Window.getComputedStyle() MDN - Examples of web and XML development using the DOM 获取元素CSS值之getComputedStyle方法熟悉 JavaScript Window getComputedStyle() Method]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.onload和$(document).ready]]></title>
    <url>%2F2019%2F08%2F08%2Fwindow.onload()%E5%92%8Cdocument.ready()%2F</url>
    <content type="text"><![CDATA[二者的区别首先需要明确window.onload属性是原生js的, 而$(document).ready是属于jQuery的, 要用后者需要先引入jQuery. 二者的区别在于$(document).ready事件发生在DOM已经完全加载(也就是DOM tree已经构建好), 做好了给JacaScript操作它们的准备了之后, 而window.onload事件发生在整个窗口页面和资源完全加载之后, 它不仅仅需要DOM加载完成, 还需要图片、iframe、CSS文件、JS等这些内容都加载好. 所以window.onload()事件发生的更晚是显而易见的. 来瞄一眼jQuery的文档是如何描述的: In most cases, the script can be run as soon as the DOM hierarchy has been fully constructed. A page can’t be manipulated safely until the document is “ready.” jQuery detects this state of readiness for you. Code included inside $( document ).ready() will only run once the page Document Object Model (DOM) is ready for JavaScript code to execute. Code included inside $( window ).on( &quot;load&quot;, function() { ... }) will run once the entire page (images or iframes), not just the DOM, is ready. 二者还有个 区别是window.onload只能用一次而$(document).ready可以多次使用(例如有多个js库时可能需要多次用ready从而做各自特定需要的操作). window.onload这种页面加载事件, 一个页面就能用一次, 很容易理解嘛, 如果硬要多次使用的话那就会造成后面的覆盖掉前面的, 就跟变量重新赋值似的. 12345678window.onload = function() &#123; console.log("1");&#125;window.onload = function() &#123;trueconsole.log("2");&#125;// 最终的结果就是后一个覆盖掉前一个, 打印出2. 正常的做法是把函数加到一个window.onload里面: 12345window.onload = function() &#123; func1(); func2(); func3();&#125; 上面这样挺好了, 可是如果函数太多的话也挺难看的, 也不够灵活. 所以可以如下定义一个addLoadEvent函数: 123456789101112function addLoadEvent(func) &#123; const oldOnload = window.onload; if (typeof window.onload !== "function") &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldOnload(); func(); &#125; &#125;&#125; 以上代码做了如下事情: 把现有的window.onload事件处理函数的值存入变量oldOnload。 如果在这个处理函数上还没有绑定的任何函数，则使用window.οnlοad=func直接调用，不需要加括号 如果在这个处理函数上已经绑定了一些函数，就把新的函数追加到现在指令的末尾。 现在, 如果某个函数需要在window.onload事件触发的时候立即执行的话, 我们只需要像下面这样: addLoadEvent(func1); addLoadEvent(func2); 你爱加多少加多少, 爱在哪儿加在哪儿加, 也很清晰明白. DOMContentLoaded事件当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。另一个不同的事件 load应该仅用于检测一个完全加载的页面。 在使用 DOMContentLoaded 更加合适的情况下使用 load 是一个令人难以置信的流行的错误, 这种错误很明显会使运行速度变慢, 所以要谨慎。 注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。 123document.addEventListener('DOMContentLoaded',function()&#123; //需要执行的代码；&#125;,false) DOMContentLonded效果跟$(document).ready相似, 但是不同浏览器有兼容问题. 例如IE低版本浏览器就没有这个事件，而所有浏览器均支持的onreadystatechange 事件能辨识readyState 属性的改变，在readyState 属性为complete时，DOM树构建完毕，这样就可以封装一个兼容低版本的函数. 12345678910111213function DOMReady(func)&#123; if(document.addEventListener)&#123; //高级浏览器支持 document.addEventListener('DOMContentLoaded',function()&#123; func &amp;&amp; func(); &#125;,false) &#125;else&#123; //低版本浏览器使用(IE) document.attachEvent("onreadychange", function()&#123; if(document.readyState == 'complete')&#123; func &amp;&amp; func(); &#125; &#125;) &#125;&#125; 说明: IE 没有document.addEventListener()方法, 所以第一个if排除IE了; else这里就是针对IE了, 由于IE没有addEventListener所以用的attachEvent绑定事件., 真他喵蛋疼. 参考: $(document).ready() vs window.onload() vs $(window).load() stackoverflow - Is $(document).ready() also CSS ready? MDN - DOMContentLoaded 简书 - DOMContentLoaded 关于JS的window.onload()方法 What, exactly, is the DOM?]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a标签的点击事件和屏蔽跳转]]></title>
    <url>%2F2019%2F08%2F07%2Fa%E6%A0%87%E7%AD%BE%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%B1%8F%E8%94%BD%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[常用的屏蔽href跳转的方法不让跳, 一般有两个思路: 第一个思路就是把href干掉, 没有有效地址看你还往哪跳; 第二个思路就是即使href地址是有效的我也无所谓, 直接把默认跳转这个行为艺术给禁咯. 个人认为第一种思路是简单粗暴的, 是不可取的, 第二种才是正确的途径. 我们应当保证HTML的语义化和可访问性, a标签就是链接嘛, 哪有链接没有有效地址的道理.(有时候有的人的存在把a当按钮用的情况, 是错误滴), 既然没地址那就说明不该用这个标签. 如果用户禁止了浏览器的JavaScript怎么办? 那就啥也看不见了? 所以第二种思路从事正确的, 即使JavaScript不起作用了, 效果差点, 至少能知道是个啥东西嘛. 方法一(思路1)1&lt;a href="javascript:void(0)" onclick="someFunction()"&gt;foo&lt;/a&gt; void 运算符, 对给定的表达式进行求值，然后返回 undefined。 方法二(思路1)1&lt;a href="###" onclick="someFunction()"&gt;bar&lt;/a&gt; 方法三(思路2)上面两种方法的href地址都是没有意义的, 如果是一个包含有意义的href地址,并且onclick之后禁止跳转到href地址的a标签呢? 我们需要对事件处理函数的工作机制有一定的了解: 在给某一个元素添加事件处理函数后, 一旦发生预定事件, 相应的 JavaScript 代码就会得到执行. 那些 JavaScript 代码可以返回一个结果, 而这个结果将被传递给那个事件处理函数. 例如, 我们可以给某个链接添加一个 onclick 事件处理函数, 并让这个处理函数触发的代码返回布尔值 true 或 false. 这样一来, 当这个链接被点击时, 如果那段 JavaScript 代码返回给 onclick 事件处理函数的值是 true, onclick 事件处理函数将认为”这个链接被点击了” 然后默认跳转; 反之, 如果那段 JavaScript 代码返回给 onclick 事件处理函数的值是 false, onclick事件处理函数将认为”这个链接没有被点击” 也就不会跳转咯. 1&lt;a href="https://www.baidu.com" onclick="someFunction;return false;"&gt;test&lt;/a&gt; 以上例子, 达到了a标签在包含有意义的href地址的情况下被点击之后执行相应函数却不跳转. 因为通过return false让它得到的反馈是自己没被点, 实际上点过了. 大傻X, 被骗了吧, 哈哈哈. 方法四(思路2)1&lt;a id="test" href="https://www.baidu.com"&gt;test&lt;/a&gt; 1234const test = document.querySelector("#test");test.onclick(function(event) &#123; event.preventDefault();&#125;) 以上例子通过取消点击事件的默认行为来禁止跳转. 参考: a标签加入单击事件 屏蔽href跳转页面 a 标签的 href 属性和 onclick 事件 MDN - void 运算符 JavaScript DOM编程艺术 - 章节4.3 p57 (事件处理函数)]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTMLCollection与NodeList]]></title>
    <url>%2F2019%2F08%2F06%2FHTMLCollection%E4%B8%8ENodeList%2F</url>
    <content type="text"><![CDATA[一、HTMLCollectionHTMLCollection对象是一个包含了元素（元素顺序为文档流中的顺序）的通用集合（generic collection）, 它提供了用来从该集合中选择元素的方法和属性。 HTML DOM 中的 HTMLCollection 是即时更新的（当其所包含的文档结构发生改变时, 它会自动更新, 所以遍历的时候需要注意. 注意：由于历史原因（DOM4之前，实现该接口的集合只能包含 HTML 元素），该接口被称为HTMLCollection。 DOM有个节点树的概念, 节点(node)有不同种类, 例如*元素节点、文本节点、属性节点… HTMLCollection中包含的HTML元素实际上就是元素节点*** nodeType一共有12种类: 元素节点 , 属性节点, 文本节点 , CDATA节点 , 实体引用名称节点, 实体名节点 , 处理指令节点 , 注释节点 , 文档节点 , 文档类型节点 , 文档片段节点, DTD声明节点 属性: HTMLCollection.length ​ 返回集合当中子元素的数目. 使用像element.getElementsByTagName()等方式获取元素的时候返回的就是HTMLCollection对象而不是数组, 所以无法使用forEach这样的数组方法遍历, 不过使用for循环遍历是可以的. 不过可以使用Array.from(someHTMLCollection)这样的方式将其转换成数组. 方法: HTMLCollection.item() 通过索引返回其中的元素 HMLCollection.namedItem() ​ 根据 Id返回指定节点，或者在不存在id的情况下根据字符串所表示的 name 属性来匹配。根据 name匹配只能作为最后的依赖，并且只有当被引用的元素支持 name 属性时才能被匹配。如果不存在符合给定 name的节点，则返回 null。 二、NodeListNodeList对象是一个节点的集合, 是由Node.childNodes和document.querySelectorAll()返回的. NodeList是一个类数组(Array-like)的对象. 在一些情况下, NodeList是一个实时的集合, 也就是说如果文档中的节点树发生变化, 已经存在的实时NodeList对象也会随之变化. 例如, Node.childNodes是实时的. 12345const parent = document.getElementById("parent");const chld_nodes = parent.childNodes;console.log(child_nodes.length); // 我们假设结果为2parent.appendChild(document.createElement("div")); console.log(chid_nodes.length); //结果变成3了 在其他情况下, NodeList是一个静态集合, 也就意味着随后对文档对象模型的任何改动都不会影响集合的内容. 比如document.querySelectorAll() 会返回一个静态的NodeList. 最好牢记这种不同, 尤其是在对NodeList进行遍历的时候. 属性: NodeList.length() 方法: NodeList.item() NodeList.entries() Returns an iterator, allowing code to go through all key/value pairs contained in the collection. (In this case, the keys are numbers starting from 0 and the values are nodes.) NodeList.forEach() Executes a provided function once per NodeList element, passing the element as an argument to the function. NodeList.keys() Returns an iterator, allowing code to go through all the keys of the key/value pairs contained in the collection. (In this case, the keys are numbers starting from 0.) NodeList.values() Returns an iterator allowing code to go through all values (nodes) of the key/value pairs contained in the collection. 总结:二者的主要区别: NodeList中可包含所有12中节点类型, HTMLCollection中只能包含元素节点这一种. NodeList是类数组对象, 拥有forEach(), entries(), keys()等方法而HTMLCollection没有. HTMLCollection是实时的, 而NodeList既可以是实时(node.childNodes返回的是实时的)也可以是静态的(node.querySelectorAll()返回的是静态的). 另外提一下, 这里谈论的NodeList的静态集合跟使用jQuery获取元素是相似的, 都是获取了就不变了. 好像有点像Linux上做快照(snapshot), 就记录那一瞬间, 哈哈. 封装一个isLive函数上面已经写得很清楚了, 记住区别就行. 下面介绍一下stackoverflow上一位答主判断HTMLCollection和NodeList什么时候静态什么时候实时的代码, 或许可以帮助理解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;isLive&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c" name="myDiv"&gt;C1&lt;/div&gt; &lt;div class="c" name="myDiv"&gt;C2&lt;/div&gt; &lt;script&gt; window.onload = function () &#123; function isLive(collection) &#123; if (collection.length &lt; 1) &#123; return undefined; &#125; let body = document.getElementsByTagName('body')[0]; let len1 = collection.length; let clone = collection.item(0).cloneNode(); clone.style.display = "none"; body.appendChild(clone); let len2 = collection.length; body.removeChild(clone); return len2 !== len1; &#125; divs1 = document.getElementsByClassName('c'); console.log("document.getElementsByClassName('c'): ",divs1.toString()); //"[object HTMLCollection]" divs2 = document.querySelectorAll('.c'); console.log("document.querySelectorAll('.c'): ",divs2.toString()); //"[object NodeList]" divs3 = document.getElementsByName('myDiv'); console.log("document.getElementsByName('myDiv'): ",divs3.toString()); //"[object NodeList"] console.log("isLive(divs1)",isLive(divs1)); //true console.log("isLive(divs2)",isLive(divs2)); //false console.log("isLive(divs3)",isLive(divs3)); //true &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; isLive函数做的事情就是: 先获取集合, 将其lengh赋值个len1, 然后从集合里面克隆一个元素并且添加到body下面, 接着将length赋值给len2, 然后为了不影响页面而删除添加的元素.如果是实时的那么集合的lenght肯定会跟着变化, 第二次赋值时的lengh就会和比第一次大1; 反之如果是静态的那么length根本不会有变化. 所以代码最后就比较了 len1和 len2相不相等, 做出了静态与实时的判断. 未来走势w3c的 Document Object Model (Core) Level 1文档里面提到node的属性childNodes的时候是这样说的: childNodes: A NodeList that contains all children of this node. If there are no children, this is a NodeList containing no nodes. The content of the returned NodeList is *”live”* in the sense that, for instance, changes to the children of the node object that it was created from are immediately reflected in the nodes returned by the NodeList accessors; it is not a static snapshot of the content of the node. This is true for every NodeList, including the ones returned by the getElementsByTagName method. 上面提到了getElementByTagName, 而且把它也当成了NodeList而不是我们前面说的HtmlCollection. 卧槽, 怎么冲突了? w3c的DOM4文档里面的 4.2.6节 Old-style collections: NodeList and HTMLCollection是这么说的: A collection is an object that represents a lists of DOM nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live. If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data. 它这意思就是说只要是collection, 无论NodeList还是HTMLCollection都是实时(live)的. 所以可能未来都是实时的了吧,不过现在还不完全是这样. 参考: Document Object Model (Core) Level 1 Understanding the difference between an HTMLCollection and a NodeList Difference between HTMLCollection, NodeLists, and arrays of objects MDN - HTMLCollection MDN - NodeList W3C - Node Types W3C - DOM4 - NodeList and HTMLCollection]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this]]></title>
    <url>%2F2019%2F08%2F05%2FJacaScript%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[一、理解常规函数中的this​ this指的是运行当前这段函数代码的对象,或者说指的是函数运行时所在的环境. 12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 ​ 对于obj.foo()来说, foo运行在obj环境, 调用者是obj, 所以this指向obj; 对于foo()来说, foo运行在全局环境, 调用者是window, 所以this指向代表全局环境的window. 不同环境不同作用域读取到的变量往往不同, 所以二者的运行结果不一样. ​ 这里我们要谈到一个叫执行上下文的东西. JavaScript中执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性：变量对象(Variable object，VO), 作用域链(Scope chain)和this. ​ 一个函数定义之后可以在很多不同的地方被调用, 函数内部的this就在函数运行时指明了执行上下文, 也就是表明了是哪个家伙 在哪里 调戏(调用)了我. 这时候函数内部就能知道作用域是什么,有哪些变量是自己可以读取到的. 简单地说,要知道this指向什么, 我们只需要搞清楚函数是在什么时候什么地方被谁如何被调用的即可, 并不需要关注函数在哪里定义或声明. ​ this是使用call()方法调用函数时传递的第一个参数(call方法一共2个参数, 第一个由于绑定this, 第二个是要传入的参数组成的数组) 他可以在函数调用时修改, 在函数没有调用的时候, this的值是无法确定的. ​ 接下来具体看看函数的调用, 以及不同情况下this指向哪里, 我们会借助call()方法来帮助理解. (一)存粹的函数调用​ 第一种方法最常见, 例子如下: 12345function test(name) &#123;trueconsole.log(name); console.log(this);&#125;test("Jerry"); ​ 这种方法我们平常使用的最多,但是这种函数调用方法只是一种简写,它完整的写法是下面这样的: 12345function test(name) &#123; console.log(name); console.log(this);&#125;test.call(undefined, "Tom"); ​ 注意上面的call方法, call方法接收的第一个参数就是this, 这里我们传了一个undefined. 那么函数执行之后console.log()出来的会是undefined吗? 不是! (传入null或者undefined默认指window对象) ​ 所以在这里调用test函数的是window, this就是指向的window全局对象. 执行上下文也就是全局执行上下文了. (二)作为对象方法的调用​ 函数还可以作为某个对象的方法调用,这时候一般this就指这个对象. (用call()方法可以例外哦) 例子: 12345678const obj = &#123; name: "Jerry", greet: function() &#123; console.log(this.name);true&#125;&#125;obj.greet(); // 第一种调用方式obj.greet.call(obj) //第二种调用方式 ​ 以上例子中的第一种调用方式实际上只是第二种方式的语法糖, 第二种才是完整的调用方法, 第二种方法厉害的地方就在于它可以手动指定this. 手动指定this的例子: 1234567const obj = &#123; name: "Jerry", greet: function() &#123;truetrueconsole.log(this.name); &#125;&#125;obj.greet.call(&#123;name: "Trump"&#125;); // 打出来是 Trump ​ 上面例子call方法调用函数时传入的是一个对象{&quot;name&quot;: &quot;Trump&quot;}, 这个对象就是手动指定的this, 因此greet()函数中console.log(this.name)打印出来的就是Trump了. 这个例子也验证了文章第一段所说的: 我们只需要搞清楚函数是在什么时候什么地方如何被调用的即可, 并不需要关注函数在哪里定义或声明. (三)构造函数中的this​ 构造函数中的this有一点特殊, 每个构造函数在new之后都会返回一个实例对象, this就指这个实例对象. 例子: 123456function Test() &#123;truethis.name = "Tom";&#125;let p = new Test();console.log(typeof p); // objectconsole.log(p.name); // Tom (四)window.setTimeout() 和window.setInterval()中函数的调用​ 他们两个函数中的this有些特殊,里面的this默认是window对象. ​ 简单总结一下：函数完整的调用方法是使用call方法，包括test.call(context, name)和obj.greet.call(context,name)，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；构造函数稍微特殊一点，它的this直接指向new之后返回的对象；window.setTimeout()和window.setInterval()默认的是this是window对象。 二、理解箭头函数中的this​ 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 (一)箭头函数默认不绑定this​ 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）。this被证明是令人厌烦的面向对象风格的编程。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。 不使用箭头函数的例子: 123456const obj = &#123; a: function() &#123; console.log(this); &#125;&#125;obj.a(); // 打印出的是obj对象 使用箭头函数的例子： 1234const obj =&#123; a: () =&gt; console.log(this)&#125;obj.a(); // 打印出来的是window ​ 上面这个例子中, 从作用域链上层(这里的上层也就是window)继承了this 再来个例子: 12345678function test() &#123; const myObj = &#123; name: "hejian", greeting: () =&gt; console.log(this) &#125; return myObj.greeting(); &#125;test(); // 打印出来的是window ​ 以上这个例子, 如果箭头函数像普通函数一样默认绑定this的话, 它的this应该指向myObj. 但是由于 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this, 所以这里就向作用域链的上级test()这一层作用域中查询,test()是个普通函数默认有this, 那么查询到这里就结束了. 那么这个this指向哪里呢? 答案就是指向window! 为了方便理解例子的最后一行可以用这种方式写: test.call(undefined) (二)不能用call方法修改箭头函数的this​ 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立） 1234567891011121314151617let adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 如上所示, 企图用call方法手动指定箭头函数的this是行不通的. 参考: 掘金 - JS中的箭头函数与this JavaScript - all about this keyword MDN - 使用对象 MDN - 使用函数]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Programming]]></title>
    <url>%2FProgramming%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类目录]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
