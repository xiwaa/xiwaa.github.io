<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[a标签的点击事件和屏蔽跳转]]></title>
    <url>%2F2019%2F08%2F07%2Fa%E6%A0%87%E7%AD%BE%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%B1%8F%E8%94%BD%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[常用的屏蔽href跳转的方法不让跳, 就两个思路嘛: 第一个思路就是把href干掉, 没有有效地址看你还往哪跳; 第二个思路就是href地址是有效的我也无所谓, 直接把你默认跳转这个行为艺术给禁咯. 方法一(思路1)1&lt;a href="javascript:void(0)" onclick="someFunction()"&gt;foo&lt;/a&gt; void 运算符, 对给定的表达式进行求值，然后返回 undefined。 方法二(思路1)1&lt;a href="###" onclick="someFunction()"&gt;bar&lt;/a&gt; 方法三(思路2)上面两种方法的href都没有有意义的href地址, 如果是一个具有有意义的链接,并且onclick之后禁止跳转到href链接的a标签呢?我们需要对事件处理函数的工作机制有一定的了解: 在给某一个元素添加事件处理函数后, 一旦发生预定事件, 相应的 JavaScript 代码就会得到执行; 那些 JavaScript 代码可以返回一个结果, 而这个结果将被传递那个事件处理函数. 例如, 我们可以给某个链接添加一个 onclick 事件处理函数, 并让这个处理函数触发的代码返回布尔值 true 或 false. 这样一来, 当这个链接被点击时, 如果那段 JavaScript 代码返回给 onclick 事件处理函数的值是 true, onclick 时间处理函数将认为”这个链接被点击了” 然后默认跳转; 反之, 如果那段 JavaScript 代码返回给 onclick 事件处理函数的值是 false, onclick事件处理函数将认为”这个链接没有被点击” 也就不会跳转咯. 1&lt;a href="https://www.baidu.com" onclick="someFunction;return false;"&gt;test&lt;/a&gt; 以上例子, 达到了a标签在有href地址的情况下被点击之后执行相应函数却不跳转. 因为通过return false让它觉得自己没被点, 实际上早他妈点过了, 哈哈哈. 方法四(思路2)1&lt;a id="test" href="https://www.baidu.com"&gt;test&lt;/a&gt; 1234const test = document.querySelector("#test");test.onclick(function(event) &#123; event.preventDefault();&#125;) 以上例子通过取消点击事件的默认行为来禁止跳转. (行为艺术很牛逼么? 说禁你就禁你, 怕不怕?) 参考: a标签加入单击事件 屏蔽href跳转页面 a 标签的 href 属性和 onclick 事件 MDN - void 运算符 JavaScript DOM编程艺术 - 章节4.3 p57 (事件处理函数)]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTMLCollection与NodeList]]></title>
    <url>%2F2019%2F08%2F06%2FHTMLCollection%E4%B8%8ENodeList%2F</url>
    <content type="text"><![CDATA[一、HTMLCollectionHTMLCollection对象是一个包含了元素（元素顺序为文档流中的顺序）的通用集合（generic collection）, 它提供了用来从该集合中选择元素的方法和属性。 HTML DOM 中的 HTMLCollection 是即时更新的（当其所包含的文档结构发生改变时, 它会自动更新, 所以遍历的时候需要注意. 注意：由于历史原因（DOM4之前，实现该接口的集合只能包含 HTML 元素），该接口被称为HTMLCollection。 DOM有个节点树的概念, 节点(node)有不同种类, 例如*元素节点、文本节点、属性节点… HTMLCollection中包含的HTML元素实际上就是元素节点*** nodeType一共有12种类: 元素节点 , 属性节点, 文本节点 , CDATA节点 , 实体引用名称节点, 实体名节点 , 处理指令节点 , 注释节点 , 文档节点 , 文档类型节点 , 文档片段节点, DTD声明节点 属性: HTMLCollection.length ​ 返回集合当中子元素的数目. 使用像element.getElementsByTagName()等方式获取元素的时候返回的就是HTMLCollection对象而不是数组, 所以无法使用forEach这样的数组方法遍历, 不过使用for循环遍历是可以的. 不过可以使用Array.from(someHTMLCollection)这样的方式将其转换成数组. 方法: HTMLCollection.item() 通过索引返回其中的元素 HMLCollection.namedItem() ​ 根据 Id返回指定节点，或者在不存在id的情况下根据字符串所表示的 name 属性来匹配。根据 name匹配只能作为最后的依赖，并且只有当被引用的元素支持 name 属性时才能被匹配。如果不存在符合给定 name的节点，则返回 null。 二、NodeListNodeList对象是一个节点的集合, 是由Node.childNodes和document.querySelectorAll()返回的. NodeList是一个类数组(Array-like)的对象. 在一些情况下, NodeList是一个实时的集合, 也就是说如果文档中的节点树发生变化, 已经存在的实时NodeList对象也会随之变化. 例如, Node.childNodes是实时的: 12345const parent = document.getElementById("parent");const chld_nodes = parent.childNodes;console.log(child_nodes.length); // 我们假设结果为2parent.appendChild(document.createElement("div")); console.log(chid_nodes.length); //结果变成3了 在其他情况下, NodeList是一个静态集合, 也就意味着随后对文档对象模型的任何改动都不会影响集合的内容. 比如document.querySelectorAll() 会返回一个静态的NodeList. 最好牢记这种不同, 尤其是在对NodeList进行遍历的时候. 属性: NodeList.length() 方法: NodeList.item() NodeList.entries() Returns an iterator, allowing code to go through all key/value pairs contained in the collection. (In this case, the keys are numbers starting from 0 and the values are nodes.) NodeList.forEach() Executes a provided function once per NodeList element, passing the element as an argument to the function. NodeList.keys() Returns an iterator, allowing code to go through all the keys of the key/value pairs contained in the collection. (In this case, the keys are numbers starting from 0.) NodeList.values() Returns an iterator allowing code to go through all values (nodes) of the key/value pairs contained in the collection. 总结一下HTMLCollection和NodeList的主要区别就在于: NodeList中可包含所有12中节点类型, HTMLCollection中只能包含元素节点这一种. NodeList是类数组对象, 拥有forEach(), entries(), keys()等方法而HTMLCollection没有. HTMLCollection是实时的, 而NodeList既可以是实时(node.childNodes返回的是实时的)也可以是静态的(node.querySelectorAll()返回的是静态的). 另外提一下, 这里谈论的NodeList的静态集合跟使用jQuery获取元素是相似的, 都是获取了就不变了. 好像有点像Linux上做快照(snapshot), 就记录那一瞬间, 哈哈. 闲扯环节上面已经写得很清楚了, 记住区别就行. 下面介绍一下stackoverflow上一位答主判断HTMLCollection和NodeList什么时候静态什么时候实时的代码, 或许可以帮助理解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;isLive&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c" name="myDiv"&gt;C1&lt;/div&gt; &lt;div class="c" name="myDiv"&gt;C2&lt;/div&gt; &lt;script&gt; window.onload = function () &#123; function isLive(collection) &#123; if (collection.length &lt; 1) &#123; return undefined; &#125; let body = document.getElementsByTagName('body')[0]; let len1 = collection.length; let clone = collection.item(0).cloneNode(); clone.style.display = "none"; body.appendChild(clone); let len2 = collection.length; body.removeChild(clone); return len2 !== len1; &#125; divs1 = document.getElementsByClassName('c'); console.log("document.getElementsByClassName('c'): ",divs1.toString()); //"[object HTMLCollection]" divs2 = document.querySelectorAll('.c'); console.log("document.querySelectorAll('.c'): ",divs2.toString()); //"[object NodeList]" divs3 = document.getElementsByName('myDiv'); console.log("document.getElementsByName('myDiv'): ",divs3.toString()); //"[object NodeList"] console.log("isLive(divs1)",isLive(divs1)); //true console.log("isLive(divs2)",isLive(divs2)); //false console.log("isLive(divs3)",isLive(divs3)); //true &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; isLive函数做的事情就是: 先获取集合, 将其lengh赋值个len1, 然后从集合里面克隆一个元素并且添加到body下面, 接着将length赋值给len2, 然后为了不影响页面而删除添加的元素.如果是实时的那么集合的lenght肯定会跟着变化, 第二次赋值时的lengh就会和比第一次大1; 反之如果是静态的那么length根本不会有变化. 所以代码最后就比较了 len1和 len2相不相等, 做出了静态与实时的判断. 参考: Understanding the difference between an HTMLCollection and a NodeList Difference between HTMLCollection, NodeLists, and arrays of objects MDN - HTMLCollection MDN - NodeList W3C - Node Types]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this]]></title>
    <url>%2F2019%2F08%2F05%2FJacaScript%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[一、理解常规函数中的this​ this指的是运行当前这段函数代码的对象,或者说指的是函数运行时所在的环境. 12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 ​ 对于obj.foo()来说, foo运行在obj环境, 调用者是obj, 所以this指向obj; 对于foo()来说, foo运行在全局环境, 调用者是window, 所以this指向全局环境. 不同环境不同作用域读取到的变量不同很正常, 所以两者的运行结果会不一样. ​ 这里我们要谈到一个叫执行上下文的玩意儿. JavaScript中执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性：变量对象(Variable object，VO), 作用域链(Scope chain)和this. ​ 一个函数定义之后可以在很多不同的地方被调用, 函数内部的this就在函数运行时指明了执行上下文, 也就是说明了是哪个家伙 在哪里 调戏(调用)了我. 这时候函数内部就能知道作用域是什么,有哪些变量是自己可以读取到的. 简单地说,要知道this指向什么, 我们只需要搞清楚函数是在什么时候什么地方被谁如何被调用的即可, 并不需要关注函数在哪里定义或声明. ​ this是使用call()方法调用函数时传递的第一个参数, 他可以在函数调用时修改, 在函数没有调用的时候, this的值是无法确定的. ​ 接下来具体看看函数的调用, 以及不同情况下this指向哪里, 我们会借助call()方法来帮助理解. (一)存粹的函数调用​ 第一种方法最常见, 例子如下: 12345function test(name) &#123;trueconsole.log(name); console.log(this);&#125;test("Jerry"); ​ 这种方法我们平常使用的最多,但是这种函数调用方法只是一种简写,它完整的写法是下面这样的: 12345function test(name) &#123; console.log(name); console.log(this);&#125;test.call(undefined, "Tom"); ​ 注意上面的call方法, call方法接收的第一个参数就是this, 这里我们传了一个undefined. 那么,依据定义,函数执行之后console.log()出来的会是undefined吗? 不是! (传入null或者undefined默认代表window对象) ​ 所以在这里调用test函数的是window, this就是指向的window全局对象. 执行上下文也就是全局执行上下文了. (二)作为对象方法的调用​ 函数还可以作为某个对象的方法调用,这时候一般this就指这个上级对象. (用call()方法可以例外哦) 例子: 12345678const obj = &#123; name: "Jerry", greet: function() &#123; console.log(this.name);true&#125;&#125;obj.greet(); // 第一种调用方式obj.greet.call(obj) //第二种调用方式 ​ 以上例子中的第一种调用方式实际上只是第二种方式的语法糖, 第二种才是完整的调用方法, 第二种方法厉害的地方就在于它可以手动指定this. 手动指定this的例子: 1234567const obj = &#123; name: "Jerry", greet: function() &#123;truetrueconsole.log(this.name); &#125;&#125;obj.greet.call(&#123;name: "Trump"&#125;); // 打出来是 Trump ​ 上面例子call方法调用函数时传入的是一个对象, 这个对象就是手动指定的this, 因此greet()行数中console.log(this.name)打印出来的就是Trump了. 这个例子也验证了文章第一段所说的: 我们只需要搞清楚函数是在什么时候什么地方如何被调用的即可, 并不需要关注函数在哪里定义或声明. (三)构造函数中的this​ 构造函数中的this有一点特殊, 每个构造函数在new之后都会返回一个实例对象, this就指这个实例对象. 例子: 123456function Test() &#123;truethis.name = "Tom";&#125;let p = new Test();console.log(typeof p); // objectconsole.log(p.name); // Tom (四)window.setTimeout() 和window.setInterval()中函数的调用​ 他们两个函数中的this有些特殊,里面的this默认是window对象. ​ 简单总结一下：函数完整的调用方法是使用call方法，包括test.call(context, name)和obj.greet.call(context,name)，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；构造函数稍微特殊一点，它的this直接指向new之后返回的对象；window.setTimeout()和window.setInterval()默认的是this是window对象。 二、理解箭头函数中的this​ 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 (一)箭头函数默认不绑定this​ 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）。this被证明是令人厌烦的面向对象风格的编程。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。 不使用箭头函数的例子: 123456const obj = &#123; a: function() &#123; console.log(this); &#125;&#125;obj.a(); // 打印出的是obj对象 使用箭头函数的例子： 1234const obj =&#123; a: () =&gt; console.log(this)&#125;obj.a(); // 打印出来的是window ​ 上面这个例子中, 从作用域链上层(这里的上层也就是window)继承了this 再来个例子: 12345678function test() &#123; const myObj = &#123; name: "hejian", greeting: () =&gt; console.log(this) &#125; return myObj.greeting(); &#125;test(); // 打印出来的是window ​ 以上这个例子, 如果箭头函数像普通函数一样默认绑定this的话, 它的this应该指向myObj. 但是由于 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this, 所以这里就向作用域链的上级test()这一层作用域中查询,test()是个普通函数默认有this, 那么查询到这里就结束了. 那么这个this指向哪里呢? 答案就是指向window! 为了方便理解例子的最后一行可以用这种方式写: test.call(undefined) (二)不能用call方法修改箭头函数的this​ 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立） 1234567891011121314151617let adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 如上所示, 企图用call方法作用与箭头函数来手动指定this是行不通的. 参考: 掘金 - JS中的箭头函数与this JavaScript - all about this keyword MDN - 使用对象 MDN - 使用函数]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Programming]]></title>
    <url>%2FProgramming%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类目录]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
